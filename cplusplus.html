

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>C++ &mdash; google-styleguide-chinese-translation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="google-styleguide-chinese-translation" href="index.html" />
    <link rel="prev" title="序言" href="introduction.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>google-styleguide-chinese-translation</span></a></h1>
        <h2 class="heading"><span>C++</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="introduction.html">序言</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="c">
<h1>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h1>
<p>C++ 是Google许多开源项目的主要开发编程语言。每个 C++ 程序员都知道，这种语言有许多强大的特性，但是这种强大也带来了程序的复杂性，这些复杂性会使程序更加容易出错，也更难去阅读和掌握。</p>
<p>这篇指南的目的是通过详细描述在 C++ 编码要怎样写而不要怎样写来避免这些复杂性。这些规则使程序仍然可以高效的使用 C++ 特性的同时也易于管理。</p>
<p>风格，也称为可读性，是我们用来管理 C++ 代码的约定。风格这个词有点用词不当，因为这些约定不止涵盖了源代码文件的格式。</p>
<p>一种我们保持程序代码易于管理的方法是保持一致性。程序员能够快速看懂其他人的代码是非常重要的。保持一种统一的风格并且遵循约定意味着我们可以轻松的用“模式匹配”来推断什么是变量什么是不变量。一般来说，遵循规范和模式使代码更容易理解。有时，可能会有一些好的建议来改变这些规则，但是我们仍然保持它们的原样来保证一致性。</p>
<p>这篇指南所讲的另一个方面是 C++ 的特性膨胀。 C++ 是一个有着许多高级特性的庞大编程语言，有时我们限制甚至禁止某些特性的使用。这样做是为了保持代码的简洁性，并且防止由于这些特性引起的不通错误和问题。这篇指南列出了这些特性并且解释了为什么要限制它们的使用。</p>
<div class="section" id="id1">
<h2>头文件<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>一般来说，每一个 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件都应该有一个和它相对应的 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件。当然也有一些例外的情况，比如单元测试代码和只包含 <tt class="docutils literal"><span class="pre">main()</span></tt> 函数的比较小的 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件。</p>
<p>正确的使用头文件能够使你代码的可读性、规模和性能有一个巨大的改观。</p>
<p>下面的规则将改正你在使用头文件上面的误区。</p>
<div class="section" id="define">
<h3>#define 保护<a class="headerlink" href="#define" title="Permalink to this headline">¶</a></h3>
<p>所有的头文件都要有 <tt class="docutils literal"><span class="pre">#define</span></tt> 保护以免被多次包含。符号名称的格式是 <tt class="docutils literal"><span class="pre">&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</span></tt> .</p>
<p>为了保证唯一性, <tt class="docutils literal"><span class="pre">define</span></tt> 声明必须基于工程代码树的全路径来命名。比如, <tt class="docutils literal"><span class="pre">foo</span></tt> 工程中的 <tt class="docutils literal"><span class="pre">foo/src/bar/baz.h</span></tt> 文件应该有如下的保护声明：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#ifndef FOO_BAR_BAZ_H_</span>
<span class="cp">#define FOO_BAR_BAZ_H_</span>

<span class="p">...</span>

<span class="cp">#endif  </span><span class="c1">// FOO_BAR_BAZ_H_</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>前向声明<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>可以通过前向声明普通类来避免不必要的 <tt class="docutils literal"><span class="pre">#include</span></tt> 包含。</p>
<div class="section" id="id3">
<h4>定义 ：<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>“前向声明”是对类，函数或者没有相关定义的模板的声明。 不管用户代码用了什么符号， <tt class="docutils literal"><span class="pre">#include</span></tt> 行经常能被前向声明替代。</p>
</div>
<div class="section" id="id4">
<h4>优点 ：<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>不必要的 <tt class="docutils literal"><span class="pre">#include</span></tt> 行使编译器打开更多的文件并且执行更多的输入操作。</li>
<li>当头文件里的内容改变后，不必要的 <tt class="docutils literal"><span class="pre">#include</span></tt> 也会使你的代码更经常的被重新编译</li>
</ul>
</div>
<div class="section" id="id5">
<h4>缺点 :<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>在存在模板，定义类型，默认参数，使用声明特性程序中，有时决定一个前向声明的正确形式是很难的。</li>
<li>有时在一段给定代码中决定使用前向声明还是 <tt class="docutils literal"><span class="pre">#include</span></tt> 包含是很难的，特别是当存在隐式转换操作的时候。在最极端的情况下， 用前向声明代替 <tt class="docutils literal"><span class="pre">#include</span></tt> 包含会悄悄的改变代码的作用。</li>
<li>从头文件中前向声明多个符号要比直接 <tt class="docutils literal"><span class="pre">#include</span></tt> 这个头文件写的更详细。</li>
<li>函数和模板的前向声明会妨碍他们所在的头文件为他们的API做兼容性改变。比如，扩大一个参数类型或者增加一个默认值的模板参数。</li>
<li>从 <tt class="docutils literal"><span class="pre">std::</span></tt> 命名空间前向声明符号经常会由于未定义而失败。</li>
<li>构建代码支持前向声明（比如，用指针成员代替对象成员）会使代码变得复杂而且运行缓慢。</li>
<li>从前向声明获得的实际效率是未经证实的。</li>
</ul>
</div>
<div class="section" id="id6">
<h4>总结 ：<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>当要用到一个头文件中的函数声明的时候，就 <tt class="docutils literal"><span class="pre">#include</span></tt> 那个头文件。</li>
<li>当要用到类模板的时候，最好 <tt class="docutils literal"><span class="pre">#include</span></tt> 那个头文件。</li>
<li>当要用到一个普通的类时，依赖一个前向声明是可以的，但是要注意前向声明可能会没有效率甚至错误；当不确定的时候，就 <tt class="docutils literal"><span class="pre">#include</span></tt> 那个头文件。</li>
<li>不要为了减掉一行 <tt class="docutils literal"><span class="pre">#include</span></tt> ，用指针去替换数据成员。</li>
</ul>
<p>总是 <tt class="docutils literal"><span class="pre">#include</span></tt> 那些提供你需要的定义或者声明的头文件；不要使用不是通过头文件直接包含进来的符号。一个例外的情况是， <tt class="docutils literal"><span class="pre">myfile.cc</span></tt> 可能会依赖它的头文件 <tt class="docutils literal"><span class="pre">myfile.h</span></tt> 中的 <tt class="docutils literal"><span class="pre">#includes</span></tt> 的头文件和前向声明。</p>
</div>
</div>
<div class="section" id="id7">
<h3>内联函数<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>只有当函数很小，比如说10行或者更少的时候，我们才会去定义内联函数。</p>
<div class="section" id="id8">
<h4>定义 ：<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>对于内联函数，编译器在编译阶段会直接展开代码，而不是像通常的函数调用机制去处理它们。</p>
</div>
<div class="section" id="id9">
<h4>优点 ：<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>只要一个函数足够小，将它声明为内联的，就能够生成更加高效的目标代码。可以随意将类成员的访问函数和设置函数和一些短而且对性能有很高要求的函数声明为内联函数。</p>
</div>
<div class="section" id="id10">
<h4>缺点 ：<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>过度的使用内联函数会使程序运行缓慢。一个内联函数的规模的大小会造成代码增加或者减少。内联一个很小的设置函数经常能够减少代码规模，而内联一个比较长的函数会急剧增加代码的规模。对于现代的处理器，小的代码段因为指令缓存的使用而运行的更快。</p>
</div>
<div class="section" id="id11">
<h4>总结 ：<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>经验告诉我们如果一个函数超过了10行，就不要内联它。要当心析构函数，由于隐式成员和基类的析构，它们往往比看起来的要长！</p>
<p>另外一个很有用的经验是 ：如果把一个含有循环和 <tt class="docutils literal"><span class="pre">switch</span></tt> 语句的函数声明为内联的，那么往往会使性能下降（除非，一般情况下，循环和 <tt class="docutils literal"><span class="pre">switch</span></tt> 是不会被执行的）。</p>
<p>必须要知道的是就算有些函数像上面定义的内联函数那样也是不能被内联的。比如，虚函数和迭代函数一般都不能被内联。让一个虚函数内联的主要原因是把它定义在类里面，不管是为了方便还是为它的行为提供文档参考，比如类成员的访问函数和设置函数。</p>
</div>
</div>
<div class="section" id="inl">
<h3>-inl 文件<a class="headerlink" href="#inl" title="Permalink to this headline">¶</a></h3>
<p>必要的时候，我们可以用 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 后缀的文件来定义复杂的内联函数。</p>
<p>内联函数的定义必须在一个头文件中，这样编译器在调用它们的地方就能知道它的函数定义。然而实现代码应当在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中，我们也不喜欢有很多实现代码在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中，除非这样做能够提高可读性和性能。</p>
<p>如果一个内联函数的定义特别短，基本没有逻辑语句在里面，那么你可以把实现代码写在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中。比如，类成员的设置和访问函数的实现就写在类声明里面。为方便实现者和调用者，更复杂的内联函数也可以放在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中，如果这样让 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件太笨拙的话，可以把代码放在一个分离的 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 文件中。这样能把实现代码从类定义里面分离出来，当需要的时候仍然可以把这些 <tt class="docutils literal"><span class="pre">.inl.h</span></tt> 文件包含进来。</p>
<p><tt class="docutils literal"><span class="pre">-inl.h</span></tt> 文件的另一个用途是函数模板的定义。这样可以让你的模板定义更容易阅读。</p>
<p>记住 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 文件和其它头文件一样也需要 <tt class="docutils literal"><span class="pre">#define</span></tt> 保护。</p>
</div>
<div class="section" id="id12">
<h3>函数参数顺序<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>当定义一个函数的时候，参数的顺序是这样的 ：输入参数，然后是输出参数。</p>
<p>C/C++ 函数的参数要么是只有输入，要么是只有输出，要么都有。输入参数一般都是常量值或者有 <tt class="docutils literal"><span class="pre">const</span></tt> 限制的，然而输出参数或者输入/输出参数不会有 <tt class="docutils literal"><span class="pre">const</span></tt> 限制。当我们对函数参数排序的时候，把所有只用作输入的参数放在所有输出参数之前。不要因为要新添参数就把它放在最后，应该还是按照规定输入输出顺序来放置。</p>
<p>当然，这也不是一个不可违逆的规则，一些既是输入又是输出的参数（经常是类或者结构体）会把这个规则搞乱。所以，保持这些函数的一致性有时需要你不一定完全遵守规则。</p>
</div>
<div class="section" id="includes">
<h3>includes 文件的名字和顺序<a class="headerlink" href="#includes" title="Permalink to this headline">¶</a></h3>
<p>要用标准的顺序来保证可读性并且避免隐含的依赖，标准的先后顺序是 : C 的头文件，C++ 的头文件， 其它第三方库的头文件和自己工程的头文件。</p>
<p>工程的所有头文件都应该安装源代码目录树的顺序来排列，而不要使用 UNIX 的简化目录 <tt class="docutils literal"><span class="pre">.</span></tt> (当前目录) 和 <tt class="docutils literal"><span class="pre">..</span></tt> （上级目录）。比如， <tt class="docutils literal"><span class="pre">google-awesome-project/src/base/logging.h</span></tt> 应该这样被包含 ：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &quot;base/logging.h&quot;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">dir/foo.cc</span></tt> 或者 <tt class="docutils literal"><span class="pre">dir/foo_test.cc</span></tt> 文件的主要功能是实现并且测试 <tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> 文件中的东西，头文件包含的顺序应该是 ：</p>
<blockquote>
<div><ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> (优先位置，详情如下)</li>
<li>C 的头文件</li>
<li>C++ 的头文件</li>
<li>其它库的头文件</li>
<li>工程的头文件</li>
</ol>
</div></blockquote>
<p>对于优先的头文件，如果 <tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> 遗漏了任何必需的 <tt class="docutils literal"><span class="pre">includes</span></tt> 行， <tt class="docutils literal"><span class="pre">dir/foo.cc</span></tt> 或者 <tt class="docutils literal"><span class="pre">dir/foo_test.cc</span></tt> 的编译都会有问题。因此，这条规则保证构建出错的时候第一个提示是对应的的头文件，而不是其它库的“无辜”的头文件。</p>
<p><tt class="docutils literal"><span class="pre">dir/foo.cc</span></tt> 和 <tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> 一般都在统一个目录（比如 <tt class="docutils literal"><span class="pre">base/basictypes_test.cc</span></tt> 和 <tt class="docutils literal"><span class="pre">base/basictypes.h</span></tt> )，但是也可以在不同的目录。</p>
<p>在每一个分类中，头文件包含的顺序都要按照字母表排序，注意比较老的代码可能没有遵守这个规则，如果方便的话就更改一下。</p>
<p>比如， <tt class="docutils literal"><span class="pre">google-awesome-project/src/foo/internal/fooserver.cc</span></tt> 文件的 <tt class="docutils literal"><span class="pre">include</span></tt> 行可能看起来是这样的 ：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &quot;foo/public/fooserver.h&quot;  </span><span class="c1">// Preferred location.</span>

<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;hash_map&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="cp">#include &quot;base/basictypes.h&quot;</span>
<span class="cp">#include &quot;base/commandlineflags.h&quot;</span>
<span class="cp">#include &quot;foo/public/bar.h&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>范围<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id14">
<h3>命名空间<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>应该鼓励在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中用未命名的命名空间。对于有名字的命名空间，要根据项目名，最好和它所在的目录一起来命名该命名空间。不要直接使用 <tt class="docutils literal"><span class="pre">using</span></tt> 语句来使用命名空间。</p>
<div class="section" id="id15">
<h4>定义 :<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>命名空间把全局范围分成不同的区域，有效的防止了全局范围内的命名冲突。</p>
</div>
<div class="section" id="id16">
<h4>优点 :<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>除了类提供命名层次外，命名空间提供了这个功能。</p>
<p>比如，如果两个不同的工程在全局都有一个叫做 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的类，这种命名在编译或者运行时可能会有冲突。如果每一个工程把它们各自的代码放在自己的命名空间里，就可以避免这个问题。 <tt class="docutils literal"><span class="pre">project1::Foo</span></tt> 和 <tt class="docutils literal"><span class="pre">project2::Foo</span></tt> 就能把这种冲突给消除。</p>
</div>
<div class="section" id="id17">
<h4>缺点 :<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>命名空间可能会让人混淆，因为除了类的层次外，命名空间又提供了一种额外的命名层次。</p>
<p>在头文件中使用未命名的命名空间很容易违反 C++ 的“只能定义一次”规则。</p>
</div>
<div class="section" id="id18">
<h4>总结 ：<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>用下面的方法来使用命名空间。用下面的例子终结所有对命名空间的讨论。</p>
<p>未命名的命名空间规则如下：</p>
<ul class="simple">
<li>允许甚至鼓励在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中使用未命名的命名空间，这样能够避免运行时的冲突：</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="n">namespace</span> <span class="p">{</span>                           <span class="c1">// This is in a .cc file.</span>

<span class="c1">// The content of a namespace is not indented</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">kUnused</span><span class="p">,</span> <span class="n">kEOF</span><span class="p">,</span> <span class="n">kError</span> <span class="p">};</span>       <span class="c1">// Commonly used tokens.</span>
<span class="n">bool</span> <span class="nf">AtEof</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pos_</span> <span class="o">==</span> <span class="n">kEOF</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// Uses our namespace&#39;s EOF.</span>

<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
<p>然而对于和特性类相关联的文件范围内声明，我们一般把它们定义成类型，数据成员或者静态成员，而不是把它们定义在未命名的命名空间里。</p>
<ul class="simple">
<li>不要在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中使用未命名的命名空间。</li>
</ul>
<p>命名的命名空间规则如下：</p>
<ul class="simple">
<li>命名空间要把 <tt class="docutils literal"><span class="pre">includes</span></tt> 行，全局定义或声明，其它命名空间类的前向声明之后所有的内容都包含：</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// In the .h file</span>
<span class="n">namespace</span> <span class="n">mynamespace</span> <span class="p">{</span>

<span class="c1">// All declarations are within the namespace scope.</span>
<span class="c1">// Notice the lack of indentation.</span>
<span class="n">class</span> <span class="n">MyClass</span> <span class="p">{</span>
 <span class="nl">public:</span>
   <span class="p">...</span>
     <span class="kt">void</span> <span class="n">Foo</span><span class="p">();</span>
     <span class="p">};</span>

  <span class="p">}</span>  <span class="c1">// namespace mynamespace</span>
  <span class="c1">// In the .cc file</span>
  <span class="n">namespace</span> <span class="n">mynamespace</span> <span class="p">{</span>

  <span class="c1">// Definition of functions is within scope of the namespace.</span>
  <span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">}</span>

 <span class="p">}</span>  <span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
<p>一般的 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件可能有更复杂的细节，比如对其它命名空间的类的引用等。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &quot;a.h&quot;</span>

<span class="n">DEFINE_bool</span><span class="p">(</span><span class="n">someflag</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">&quot;dummy flag&quot;</span><span class="p">);</span>

<span class="n">class</span> <span class="n">C</span><span class="p">;</span>  <span class="c1">// Forward declaration of class C in the global namespace.</span>
<span class="n">namespace</span> <span class="n">a</span> <span class="p">{</span> <span class="n">class</span> <span class="n">A</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// Forward declaration of a::A.</span>

<span class="n">namespace</span> <span class="n">b</span> <span class="p">{</span>

<span class="p">...</span><span class="n">code</span> <span class="k">for</span> <span class="n">b</span><span class="p">...</span>         <span class="c1">// Code goes against the left margin.</span>

<span class="p">}</span>  <span class="c1">// namespace b</span>
</pre></div>
</div>
<ul class="simple">
<li>不要声明命名空间 <tt class="docutils literal"><span class="pre">std</span></tt> 下的任何内容，包括标准库类的前向声明。声明命名空间 <tt class="docutils literal"><span class="pre">std</span></tt> 中的实体会导致未知的行为，比如不可移植性。为了声明标准库中的实体，可以包含相应的头文件。</li>
<li>不应改直接用一个 <tt class="docutils literal"><span class="pre">using</span></tt> 语句使该命名空间中的所有名字都可用。</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Forbidden -- This pollutes the namespace.</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>可以在任何位置用 <tt class="docutils literal"><span class="pre">using</span></tt> 声明，比如 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件，函数里，方法里或者 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中。</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// OK in .cc files.</span>
<span class="c1">// Must be in a function, method or class in .h files.</span>
<span class="n">using</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>可以在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件的任何位置使用命名空间别名，在包含整个 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件的有名字的命名空间内，函数和方法内，也可以使用命名空间别名。</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Shorten access to some commonly used names in .cc files.</span>
<span class="n">namespace</span> <span class="n">fbz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>

<span class="c1">// Shorten access to some commonly used names (in a .h file).</span>
<span class="n">namespace</span> <span class="n">librarian</span> <span class="p">{</span>
<span class="c1">// The following alias is available to all files including</span>
<span class="c1">// this header (in namespace librarian):</span>
<span class="c1">// alias names should therefore be chosen consistently</span>
<span class="c1">// within a project.</span>
<span class="n">namespace</span> <span class="n">pd_s</span> <span class="o">=</span> <span class="o">::</span><span class="n">pipeline_diagnostics</span><span class="o">::</span><span class="n">sidetable</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">my_inline_function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// namespace alias local to a function (or method).</span>
    <span class="n">namespace</span> <span class="n">fbz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>
      <span class="p">...</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace librarian</span>
</pre></div>
</div>
<p>要知道 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中的别名在任何包含这个头文件的文件中都是有效的，所以那些公共的头文件（在工程外可用）和它们包含的一些头文件都应该避免使用别名，因为一般来说应该把公共 API 的范围控制到最小。</p>
</div>
</div>
<div class="section" id="id19">
<h3>嵌套类<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>当一个嵌套类是接口的一部分时，可能就会用到，但是最好用命名空间把它们的定义从全局范围隔离开来。</p>
<div class="section" id="id20">
<h4>定义<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>在一个类里面可以定义另一个类，也可以叫作成员类。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">class</span> <span class="n">Foo</span> <span class="p">{</span>

<span class="nl">private:</span>
    <span class="c1">// Bar is a member class, nested within Foo.</span>
    <span class="n">class</span> <span class="n">Bar</span> <span class="p">{</span>
         <span class="p">...</span>
    <span class="p">};</span>

<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4>优点<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>当嵌套类（或者成员类）只在类里面被使用的话是很有用的；把它作为一个成员放在类里面比声明在外面要好的多。嵌套类可以前向声明在包含它的类里面，并且在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中定义它，这样可以避免在类中有嵌套类的定义，这样嵌套类的定义就只与实现文件有关了。</p>
</div>
<div class="section" id="id22">
<h4>缺点<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>嵌套类在被前向声明的时候只能连同包含它的类一起。因此，任何操作 <tt class="docutils literal"><span class="pre">Foo::Bar*</span></tt> 指针的头文件都必须包含 <tt class="docutils literal"><span class="pre">Foo</span></tt> 整个类的声明。</p>
</div>
<div class="section" id="id23">
<h4>总结<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>除了当嵌套类是接口的一部分外，不要把嵌套类声明成公开的，比如一些方法使用了这个类的选项。</p>
</div>
</div>
<div class="section" id="id24">
<h3>非成员函数，静态成员函数和全局函数<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>最好使用命名空间中的非成员函数或者静态成员函数，而不要使用全局函数。</p>
<div class="section" id="id25">
<h4>优点<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<p>非成员函数和静态成员函数有时非常有用。把非成员函数放在命名空间中可以避免对全局作用域的污染。</p>
</div>
<div class="section" id="id26">
<h4>缺点<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<p>把非成员函数喝静态成员函数作为一个新类的成员或许会更有意义，特别是当它们想访问外部资源或者有明显的依赖关系的时候。</p>
</div>
<div class="section" id="id27">
<h4>总结<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>有时定义一个没有绑定到类的函数是很有用的，甚至是必须的。它们可以是非成员函数或者是静态成员函数。非成员函数不要对外部变量有依赖并且几乎要存在在一个命名空间里。相比于新创建一个类来把静态成员函数集合起来，使用命名空间可能更好一点。</p>
<p>作为生产类，定义在同一个编译单元内的函数在被其它编译单元调用的时候会引入不必要的耦合和链接时的依赖关系，静态成员函数对这一点尤为敏感。考虑新建一个类或者可能的话把这些函数放在一个命名空间中。</p>
<p>如果一定要定义一个非成员函数并且只有 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件用到它的话，用一个未名的命名空间或者 <tt class="docutils literal"><span class="pre">static</span></tt> 关键字（比如 <tt class="docutils literal"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">Foo()</span></tt> ）来限制它们的范围。</p>
</div>
</div>
<div class="section" id="id28">
<h3>局部变量<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>尽可能将函数的局部变量限制在最小的作用范围内，最好在声明它的时候就初始化。</p>
<p>C++ 允许在函数的任何地方声明变量。我们提倡在尽可能小的作用域里声明它们，离第一次使用越近越好。这样阅读的人也更容易找到它的声明知道变量的类型和初始值。特别的，应该用初始化代替声明和定义，比如：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>      <span class="c1">// Bad -- initialization separate from declaration.</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="p">();</span>  <span class="c1">// Good -- declaration has initialization.</span>
</pre></div>
</div>
<p>注意 <tt class="docutils literal"><span class="pre">gcc</span></tt> 编译器可以正确执行 <tt class="docutils literal"><span class="pre">for</span> <span class="pre">(int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10;</span> <span class="pre">i++)</span></tt> (<tt class="docutils literal"><span class="pre">i</span></tt> 的作用域在循环里面)，因此你可以在其它的 <tt class="docutils literal"><span class="pre">for</span></tt> 循环中再次使用变量 <tt class="docutils literal"><span class="pre">i</span></tt> 。在 <tt class="docutils literal"><span class="pre">if</span></tt> 和 <tt class="docutils literal"><span class="pre">while</span></tt> 语句中这样声明也是正确的，比如：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">))</span> <span class="n">str</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>警告一下：如果变量是一个对象，每当进入作用域都要调用其构造函数，每次离开作用域都要调用其析构函数。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Inefficient implementation:</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>  <span class="c1">// My ctor and dtor get called 1000000 times each.</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在循环外面声明这样的变量会更有效率一些：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>  <span class="c1">// My ctor and dtor get called once each.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h3>静态变量和全局变量<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>类的静态变量或者全局变量是禁止的：由于构造和析构函数执行的顺序不确定性，很容易引起找不到定义的错误。然而 <tt class="docutils literal"><span class="pre">const</span></tt> 修饰的变量是可以这样声明的因为它们不会动态初始化或者析构。</p>
<p>静态存储期的对象，包括全局变量，静态变量，静态成员变量，静态函数变量，一定要是简单的数据类型：整型，字符，浮点，数组或者结构。</p>
<p>在 C++ 中，对类的静态变量的构造和初始化的顺序只是部分定义的，每次构建可能都不一样，这样就很可能出现很难查找的 bug。因此除了禁止类的全局变量，我们也不允许静态变量在函数中初始化，除非那些函数自身不依赖其它的全局变量。</p>
<p>同样的，析构函数被调用的顺序和构造函数是相反的，由于构造顺序是不确定的，所以析构的顺序也是不确定的。比如，在程序结束的时候一个静态变量可能已经被销毁了，带是代码仍然在运行，可能在其它的线程里，想要获取它的值但是会失败。或者是一个静态 <tt class="docutils literal"><span class="pre">string</span></tt> 类型的变量肯能在销毁之前被另一个变量引用了，那么析构之后也会出错。</p>
<p>总而言之，我们只允许普通数据类型的静态变量。所以完全不允许 <tt class="docutils literal"><span class="pre">vector</span></tt> (用 C 的数组代替) 或者 <tt class="docutils literal"><span class="pre">string</span></tt> （用 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">[]</span></tt> 代替） 的静态变量。</p>
<p>如果你需要一个静态或者全局的类类型的变量，考虑在 <tt class="docutils literal"><span class="pre">main()</span></tt> 函数或者 <tt class="docutils literal"><span class="pre">pthread_once()</span></tt> 函数中用指针去初始化（）。注意一定要是一个原始的指针，因为聪明的指针析构存在我们正在避免的析构顺序问题。</p>
</div>
</div>
<div class="section" id="id30">
<h2>类<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<p>类是 C++ 的基本单元。自然而然的，我们在项目中广泛的运用它。这一节列举了在写一个类的时候应该和不应改做的事情。</p>
<div class="section" id="id31">
<h3>构造函数<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h3>
<p>避免在构造函数中做很复杂的初始化工作（特别是那些可能会失败或者需要虚方法调用的初始化工作）。</p>
<div class="section" id="id32">
<h4>定义 ：<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h4>
<p>可以在构造函数中执行初始化。</p>
</div>
<div class="section" id="id33">
<h4>优点 ：<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<p>排版方便；无需担心类是否被初始化了。</p>
</div>
<div class="section" id="id34">
<h4>缺点 ：<a class="headerlink" href="#id34" title="Permalink to this headline">¶</a></h4>
<p>在构造函数中操作的问题如下:</p>
<ul class="simple">
<li>构造函数不容易报告错误，也禁止使用异常机制。</li>
<li>如果操作失败了，就会有一个对象的初始化操作失败了，这是一种不确定的状态。</li>
<li>如果构造函数中调用了虚函数，这些调用不会被派发到子类的实现中。即使你的类现在还有子类，但是未来对类很小的改变都会引起很大的错误。</li>
<li>如果有人创建了这个类的一个全局变量（尽管违反了规则，但是他仍然这样做了），构造函数会在 <tt class="docutils literal"><span class="pre">main()</span></tt> 函数之前被调用，可能会打破一些构造函数中隐式的假设，比如，全局标志（gflag）还没有被初始化。</li>
</ul>
</div>
<div class="section" id="id35">
<h4>总结<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h4>
<p>构造函数不能调用虚函数或者可能引起非致命的错误。如果你的对象需要重要的初始化，考虑用一个工厂函数或者 <tt class="docutils literal"><span class="pre">Init()</span></tt> 方法。</p>
</div>
</div>
<div class="section" id="id36">
<h3>默认构造函数<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h3>
<p>如果你的类定义了成员变量，没有其它的构造函数，你要定义一个默认的够砸奥函数。否则，编译器会自己做构造操作，效果很差。</p>
<div class="section" id="id37">
<h4>定义 ：<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h4>
<p>当我们 <tt class="docutils literal"><span class="pre">new</span></tt> 一个不带参数的类对象的时候，默认构造函数就会被调用。当调用 <tt class="docutils literal"><span class="pre">new[]</span></tt> （为数组）的时候，默认构造函数也会被调用。</p>
</div>
<div class="section" id="id38">
<h4>优点 ：<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h4>
<p>默认将结构初始化成“不可能”的值，使调试变得更加容易。</p>
</div>
<div class="section" id="id39">
<h4>缺点 ：<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<p>对于代码编写者来说，这是多余的工作。</p>
</div>
<div class="section" id="id40">
<h4>总结 ：<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h4>
<p>如果你的类定义了成员变量并且没有其它的构造函数，你要定义一个默认的构造函数（一个不带参数的构造函数）。它最好能够使对象初始化之后，内部的状态保持一致和正确。</p>
<p>这样做的原因是如果你没有其它的构造函数，也不定义一个默认构造函数的话，编译器会为你自动产生一个。但是产生的构造函数可能不会很明智的初始化你的对象。</p>
<p>如果你的类是从其它类继承的并且你没有增加新的成员变量，你不许要再去新建一个默认构造函数。</p>
</div>
</div>
<div class="section" id="id41">
<h3>显式构造函数<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h3>
<p>用 C++ 的关键字 <tt class="docutils literal"><span class="pre">explicit</span></tt> 去修饰只含有一个参数的构造函数。</p>
<div class="section" id="id42">
<h4>定义 ：<a class="headerlink" href="#id42" title="Permalink to this headline">¶</a></h4>
<p>一般来说，如果一个构造函数只有一个参数，可以把它用作一个转换。比如，如果你定义了 <tt class="docutils literal"><span class="pre">Foo::Foo(string</span> <span class="pre">name)</span></tt> ，然后当向一个需要 <tt class="docutils literal"><span class="pre">Foo</span></tt> 对象的函数传递一个 <tt class="docutils literal"><span class="pre">string</span></tt> 时，构造函数会被调用把这个字符床转换成一个 <tt class="docutils literal"><span class="pre">Foo</span></tt> 对象然后把这个对象传递给函数。这样有时很方便，但是当你不想这样做，麻烦也会随之而来。把构造函数声明成 <tt class="docutils literal"><span class="pre">explicit</span></tt> 的能够防止这样隐式转换的发生。</p>
</div>
<div class="section" id="id43">
<h4>优点 ：<a class="headerlink" href="#id43" title="Permalink to this headline">¶</a></h4>
<p>避免不合适的转换。</p>
</div>
<div class="section" id="id44">
<h4>缺点 ：<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h4>
<p>无</p>
</div>
<div class="section" id="id45">
<h4>总结 ：<a class="headerlink" href="#id45" title="Permalink to this headline">¶</a></h4>
<p>我们希望所有只有一个参数的构造函数都是 <tt class="docutils literal"><span class="pre">explicit</span></tt> 的，总是用 <tt class="docutils literal"><span class="pre">explicit</span></tt> 去修饰只有一个参数的构造函数 ： <tt class="docutils literal"><span class="pre">explicit</span> <span class="pre">Foo(string</span> <span class="pre">name)</span></tt>;</p>
<p>极少数情况下，当我们允许拷贝构造的时候，这就是是一个例外了，构造函数就不应改用 <tt class="docutils literal"><span class="pre">explicit</span></tt> 来修饰。透明包装其它类的类也是一个例外。这样例外的情况应该用注释说明清楚。</p>
</div>
</div>
<div class="section" id="id46">
<h3>拷贝构造函数<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h3>
<p>只有需要的时候才提供拷贝构造函数和赋值操作。否则，用 <tt class="docutils literal"><span class="pre">DISALLOW_COPY_AND_ASSIGN</span></tt> 去禁止他们。</p>
<div class="section" id="id47">
<h4>定义 ：<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h4>
<p>拷贝构造函数和复制操作用来创建对象的拷贝。在一些情况下，拷贝构造函数会被编译器隐式的调用，比如直接把值传给对象。</p>
</div>
<div class="section" id="id48">
<h4>优点 ：<a class="headerlink" href="#id48" title="Permalink to this headline">¶</a></h4>
<p>拷贝构造让拷贝对象更加容易。STL容器的所有类型都是可拷贝和被赋值的。拷贝构造比 <tt class="docutils literal"><span class="pre">CopyFrom()</span></tt> 类型的函数更有效率，因为它们在拷贝的时候结合了构造函数，编译器可能不把它们放在正文段中，这样可以避免堆的分配。</p>
</div>
<div class="section" id="id49">
<h4>缺点 ：<a class="headerlink" href="#id49" title="Permalink to this headline">¶</a></h4>
<p>在 C++ 中，隐式的对象拷贝是错误的重要来源。不像引用操作，由于很难去跟踪被传递的对象，拷贝构造也降低了程序的可读性，哪里修改的对象也变得难以跟踪。</p>
</div>
<div class="section" id="id50">
<h4>总结 ：<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h4>
<p>基本没有类需要被拷贝。大多数都不需要拷贝构造和赋值操作。很多情况下，指针或者引用可以有拷贝一样的效果，且性能更好。比如，你可以向函数传递指针或者引用参数，而不是值，你也可以在 STL 容器中保存指针，而不是对象。</p>
<p>如果你的类需要被拷贝，最好提供一个拷贝方法，比如 <tt class="docutils literal"><span class="pre">CopyFrom()</span></tt> 或者 <tt class="docutils literal"><span class="pre">Clone()</span></tt> 而不是用拷贝构造，因为这样的方法是不会被隐式调用的。如果在你的情形下，拷贝方法是不够的（比如性能要求或者你的类需要以值的形式存在 STL 容器中），那么提供一个拷贝构造和赋值操作。</p>
<p>如果你的类不需要拷贝构造和赋值操作，必须显式的禁止它们。为了这样做，可以在类的 <tt class="docutils literal"><span class="pre">private</span></tt> 部分为拷贝构造和赋值操作声明一个假的声明 ：但是不要提供任何相关的定义（这样任何想要调用它们的操作都会有一个链接错误）。</p>
<p>为了方便， <tt class="docutils literal"><span class="pre">DISALLOW_COPY_AND_ASSIGN</span></tt> 宏可以这样用：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">// A macro to disallow the copy constructor and operator= functions</span>
<span class="cp">// This should be used in the private: declarations for a class</span>
<span class="cp">#define DISALLOW_COPY_AND_ASSIGN(TypeName) \</span>
<span class="cp">    TypeName(const TypeName&amp;);               \</span>
<span class="cp">    void operator=(const TypeName&amp;)</span>
</pre></div>
</div>
<p>然后，在 <tt class="docutils literal"><span class="pre">Foo</span></tt> 类中：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">class</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">f</span><span class="p">);</span>
         <span class="o">~</span><span class="n">Foo</span><span class="p">();</span>

    <span class="nl">private:</span>
        <span class="n">DISALLOW_COPY_AND_ASSIGN</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id51">
<h3>结构和类的比较<a class="headerlink" href="#id51" title="Permalink to this headline">¶</a></h3>
<p>当对象只包含数据的时候用结构，其余的情况都要用类。</p>
<p>C++ 中结构和类关键字的表现几乎是一样的。我们人为为它们的添加自己的语义，因此我们必须为我们定义的数据类型使用合适的关键字。</p>
<p>结构只能用在只包含数据的对象上，它可能也有一些关联的变量，但是没有存取之外的任何函数。存取操作是通过直接访问结构中的域来完成的，而不是通过方法调用。这里的方法指的是处理数据成员的方法，比如构造函数，析构函数， <tt class="docutils literal"><span class="pre">Initialize()</span></tt>, <tt class="docutils literal"><span class="pre">Reset()</span></tt>, <tt class="docutils literal"><span class="pre">Validate()</span></tt> 函数。</p>
<p>如果需要其它的函数功能，用类会更合适。如果你不确定的话，就用类。</p>
<p>当和 STL 结合使用的时候，可以为了仿函数和特征用结构代替类。</p>
<p>注意结构和类中的成员变量有不通的命名规则。</p>
</div>
<div class="section" id="id52">
<h3>继承<a class="headerlink" href="#id52" title="Permalink to this headline">¶</a></h3>
<p>用组合往往比用继承要合适。当我们用继承的时候，要用 <tt class="docutils literal"><span class="pre">public</span></tt> 继承。</p>
<div class="section" id="id53">
<h4>定义 :<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h4>
<p>当一个子类从基类集成的时候，它就包含了基类定义的所有数据和操作。一般来说，C++ 的继承有两个主要的用途：实现继承，这种继承下子类继承了父类的代码；接口继承，只有方法名字被继承了。</p>
</div>
<div class="section" id="id54">
<h4>优点 ：<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h4>
<p>实现继承通过复用基类定义的代码减少了代码量。因为继承是编译时声明，你和编译器都可以理解这些操作并且检查错误。接口继承是用来代码实现一个类暴露的特定 API。同样的，如果一个继承类没有定义必需的方法，编译器可以检查错误。</p>
</div>
<div class="section" id="id55">
<h4>缺点 ：<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h4>
<p>对于实现继承，由于子类的代码包括基类和子类自己的，所以很难看懂代码。子类不能重写一个非虚函数，所以子类不能改变一些代码的实现。基类也会定义一些数据成员，所以还要区分基类的物理布局。</p>
</div>
<div class="section" id="id56">
<h4>总结 ：<a class="headerlink" href="#id56" title="Permalink to this headline">¶</a></h4>
<p>所有的继承必须是 <tt class="docutils literal"><span class="pre">public</span></tt> 的。如果你想要用 <tt class="docutils literal"><span class="pre">private</span></tt> 继承，要声明一个父类句柄的成员。</p>
<p>不要过度使用实现继承。组合一般会更合适。尽量在只有 <tt class="docutils literal"><span class="pre">is-a</span></tt> 关系的时候才用继承：如果 <tt class="docutils literal"><span class="pre">Bar</span></tt> 是 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的一种，那么可以让 <tt class="docutils literal"><span class="pre">Bar</span></tt> 继承 <tt class="docutils literal"><span class="pre">Foo</span></tt> 。</p>
<p>尽量让析构函数是虚函数。如果类里面有虚函数，那么析构函数应该也是虚函数。</p>
<p>限定仅在子类访问的成员为 <tt class="docutils literal"><span class="pre">protected</span></tt> 的。注意数据成员应该是 <tt class="docutils literal"><span class="pre">private</span></tt> 的。</p>
<p>当再次定义继承的虚函数的时候，在派生类中显式的声明它为 <tt class="docutils literal"><span class="pre">virtual</span></tt> 的。原因：如果没有 <tt class="docutils literal"><span class="pre">virtual</span></tt> 的话，读者需要检查它所有的祖先来确定它是否是虚函数。</p>
</div>
</div>
<div class="section" id="id57">
<h3>多重继承<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h3>
<p>很少情况下，多重实现继承才是有用的。只有当最多一个基类有实现代码，其它基类都是接口类的时候，才允许多重继承。</p>
<div class="section" id="id58">
<h4>定义 ：<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h4>
<p>多重继承允许一个子类有多余一个的基类。要将纯接口的基类和有实现的基类分开。</p>
</div>
<div class="section" id="id59">
<h4>优点 ：<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h4>
<p>多重继承比单继承可以重用更多的代码。</p>
</div>
<div class="section" id="id60">
<h4>缺点 ：<a class="headerlink" href="#id60" title="Permalink to this headline">¶</a></h4>
<p>极少情况下多重继承才有用。当觉得多重继承看上去是个解决方法的时候，你一般可以找到一个不同的更加明确清晰的解决方案。</p>
</div>
<div class="section" id="id61">
<h4>总结 ：<a class="headerlink" href="#id61" title="Permalink to this headline">¶</a></h4>
<p>只有当所有的基类，最多只有一个不是纯接口，其它都是的情况下，才去用多重继承。为了保证这些类是纯接口，必须以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 作为后缀。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在 Windows系统中有一个例外</p>
</div>
</div>
</div>
<div class="section" id="id62">
<h3>接口<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h3>
<p>接口是满足特定条件的类，往往以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 结尾，但是不是必须的。</p>
<div class="section" id="id63">
<h4>定义 ：<a class="headerlink" href="#id63" title="Permalink to this headline">¶</a></h4>
<p>如果一个类满足下面的条件，它就是纯接口 ：
* 它只有公共的纯虚函数和静态方法（下文提到的析构函数除外）。
* 不能有非静态数据成员。
* 不需要定义任何构造函数，如果提供的话，它必须没有参数并且是 <tt class="docutils literal"><span class="pre">protected</span></tt> 的。
* 如果它是子类，那么它也是从满足上面条件并且以 <tt class="docutils literal"><span class="pre">Interface</span></tt> 结尾的类继承而来。</p>
<p>由于声明了纯虚函数，接口不能被实例化。为了保证接口类的所有实现都能被正确的销毁，必须为它声明一个虚析构函数（上面第一条要求的例外，析构函数不能是纯虚的），详见 Stroustrup 的 The C++ Programming Language 第三版 12.4 章节。</p>
</div>
<div class="section" id="id64">
<h4>优点 ：<a class="headerlink" href="#id64" title="Permalink to this headline">¶</a></h4>
<p>为一个类加上 <tt class="docutils literal"><span class="pre">Interface</span></tt> 后缀让别人知道不能为它增加实现的方法或者非静态数据成员。这一点在多重继承中尤为重要。除此之外，接口的概念对 Java 程序员来说已经很熟悉了。</p>
</div>
<div class="section" id="id65">
<h4>缺点 ：<a class="headerlink" href="#id65" title="Permalink to this headline">¶</a></h4>
<p><tt class="docutils literal"><span class="pre">Interface</span></tt> 后缀增加了类名的长度，使程序难以阅读和理解。同时，接口可能被认为是实现细节，不能暴露给用户。</p>
</div>
<div class="section" id="id66">
<h4>总结 ：<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h4>
<p>只有当一个类满足上面的要求才能加上 <tt class="docutils literal"><span class="pre">Interface</span></tt> 后缀。但是满足上面条件的类也不一定要加上 <tt class="docutils literal"><span class="pre">Interface</span></tt> 后缀。</p>
</div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="introduction.html">序言</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, wangwei.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>