

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>C++ &mdash; google-styleguide-chinese-translation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="google-styleguide-chinese-translation" href="index.html" />
    <link rel="prev" title="序言" href="introduction.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>google-styleguide-chinese-translation</span></a></h1>
        <h2 class="heading"><span>C++</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="introduction.html">序言</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="c">
<h1>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h1>
<p>C++ 是Google许多开源项目的主要开发编程语言。每个 C++ 程序员都知道，这种语言有许多强大的特性，但是这种强大也带来了程序的复杂性，这些复杂性会使程序更加容易出错，也更难去阅读和掌握。</p>
<p>这篇指南的目的是通过详细描述在 C++ 编码要怎样写而不要怎样写来避免这些复杂性。这些规则使程序仍然可以高效的使用 C++ 特性的同时也易于管理。</p>
<p>风格，也称为可读性，是我们用来管理 C++ 代码的约定。风格这个词有点用词不当，因为这些约定不止涵盖了源代码文件的格式。</p>
<p>一种我们保持程序代码易于管理的方法是保持一致性。程序员能够快速看懂其他人的代码是非常重要的。保持一种统一的风格并且遵循约定意味着我们可以轻松的用“模式匹配”来推断什么是变量什么是不变量。一般来说，遵循规范和模式使代码更容易理解。有时，可能会有一些好的建议来改变这些规则，但是我们仍然保持它们的原样来保证一致性。</p>
<p>这篇指南所讲的另一个方面是 C++ 的特性膨胀。 C++ 是一个有着许多高级特性的庞大编程语言，有时我们限制甚至禁止某些特性的使用。这样做是为了保持代码的简洁性，并且防止由于这些特性引起的不通错误和问题。这篇指南列出了这些特性并且解释了为什么要限制它们的使用。</p>
<div class="section" id="id1">
<h2>头文件<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>一般来说，每一个 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件都应该有一个和它相对应的 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件。当然也有一些例外的情况，比如单元测试代码和只包含 <tt class="docutils literal"><span class="pre">main()</span></tt> 函数的比较小的 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件。</p>
<p>正确的使用头文件能够使你代码的可读性、规模和性能有一个巨大的改观。</p>
<p>下面的规则将改正你在使用头文件上面的误区。</p>
<div class="section" id="define">
<h3>#define 保护<a class="headerlink" href="#define" title="Permalink to this headline">¶</a></h3>
<p>所有的头文件都要有 <tt class="docutils literal"><span class="pre">#define</span></tt> 保护以免被多次包含。符号名称的格式是 <tt class="docutils literal"><span class="pre">&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</span></tt> .</p>
<p>为了保证唯一性, <tt class="docutils literal"><span class="pre">define</span></tt> 声明必须基于工程代码树的全路径来命名。比如, <tt class="docutils literal"><span class="pre">foo</span></tt> 工程中的 <tt class="docutils literal"><span class="pre">foo/src/bar/baz.h</span></tt> 文件应该有如下的保护声明：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#ifndef FOO_BAR_BAZ_H_</span>
<span class="cp">#define FOO_BAR_BAZ_H_</span>

<span class="p">...</span>

<span class="cp">#endif  </span><span class="c1">// FOO_BAR_BAZ_H_</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h3>前向声明<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>可以通过前向声明普通类来避免不必要的 <tt class="docutils literal"><span class="pre">#include</span></tt> 包含。</p>
<div class="section" id="id3">
<h4>定义 ：<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>“前向声明”是对类，函数或者没有相关定义的模板的声明。 不管用户代码用了什么符号， <tt class="docutils literal"><span class="pre">#include</span></tt> 行经常能被前向声明替代。</p>
</div>
<div class="section" id="id4">
<h4>优点 ：<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>不必要的 <tt class="docutils literal"><span class="pre">#include</span></tt> 行使编译器打开更多的文件并且执行更多的输入操作。</li>
<li>当头文件里的内容改变后，不必要的 <tt class="docutils literal"><span class="pre">#include</span></tt> 也会使你的代码更经常的被重新编译</li>
</ul>
</div>
<div class="section" id="id5">
<h4>缺点 :<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>在存在模板，定义类型，默认参数，使用声明特性程序中，有时决定一个前向声明的正确形式是很难的。</li>
<li>有时在一段给定代码中决定使用前向声明还是 <tt class="docutils literal"><span class="pre">#include</span></tt> 包含是很难的，特别是当存在隐式转换操作的时候。在最极端的情况下， 用前向声明代替 <tt class="docutils literal"><span class="pre">#include</span></tt> 包含会悄悄的改变代码的作用。</li>
<li>从头文件中前向声明多个符号要比直接 <tt class="docutils literal"><span class="pre">#include</span></tt> 这个头文件写的更详细。</li>
<li>函数和模板的前向声明会妨碍他们所在的头文件为他们的API做兼容性改变。比如，扩大一个参数类型或者增加一个默认值的模板参数。</li>
<li>从 <tt class="docutils literal"><span class="pre">std::</span></tt> 命名空间前向声明符号经常会由于未定义而失败。</li>
<li>构建代码支持前向声明（比如，用指针成员代替对象成员）会使代码变得复杂而且运行缓慢。</li>
<li>从前向声明获得的实际效率是未经证实的。</li>
</ul>
</div>
<div class="section" id="id6">
<h4>总结 ：<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>当要用到一个头文件中的函数声明的时候，就 <tt class="docutils literal"><span class="pre">#include</span></tt> 那个头文件。</li>
<li>当要用到类模板的时候，最好 <tt class="docutils literal"><span class="pre">#include</span></tt> 那个头文件。</li>
<li>当要用到一个普通的类时，依赖一个前向声明是可以的，但是要注意前向声明可能会没有效率甚至错误；当不确定的时候，就 <tt class="docutils literal"><span class="pre">#include</span></tt> 那个头文件。</li>
<li>不要为了减掉一行 <tt class="docutils literal"><span class="pre">#include</span></tt> ，用指针去替换数据成员。</li>
</ul>
<p>总是 <tt class="docutils literal"><span class="pre">#include</span></tt> 那些提供你需要的定义或者声明的头文件；不要使用不是通过头文件直接包含进来的符号。一个例外的情况是， <tt class="docutils literal"><span class="pre">myfile.cc</span></tt> 可能会依赖它的头文件 <tt class="docutils literal"><span class="pre">myfile.h</span></tt> 中的 <tt class="docutils literal"><span class="pre">#includes</span></tt> 的头文件和前向声明。</p>
</div>
</div>
<div class="section" id="id7">
<h3>内联函数<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>只有当函数很小，比如说10行或者更少的时候，我们才会去定义内联函数。</p>
<div class="section" id="id8">
<h4>定义 ：<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>对于内联函数，编译器在编译阶段会直接展开代码，而不是像通常的函数调用机制去处理它们。</p>
</div>
<div class="section" id="id9">
<h4>优点 ：<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>只要一个函数足够小，将它声明为内联的，就能够生成更加高效的目标代码。可以随意将类成员的访问函数和设置函数和一些短而且对性能有很高要求的函数声明为内联函数。</p>
</div>
<div class="section" id="id10">
<h4>缺点 ：<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>过度的使用内联函数会使程序运行缓慢。一个内联函数的规模的大小会造成代码增加或者减少。内联一个很小的设置函数经常能够减少代码规模，而内联一个比较长的函数会急剧增加代码的规模。对于现代的处理器，小的代码段因为指令缓存的使用而运行的更快。</p>
</div>
<div class="section" id="id11">
<h4>总结 ：<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>经验告诉我们如果一个函数超过了10行，就不要内联它。要当心析构函数，由于隐式成员和基类的析构，它们往往比看起来的要长！</p>
<p>另外一个很有用的经验是 ：如果把一个含有循环和 <tt class="docutils literal"><span class="pre">switch</span></tt> 语句的函数声明为内联的，那么往往会使性能下降（除非，一般情况下，循环和 <tt class="docutils literal"><span class="pre">switch</span></tt> 是不会被执行的）。</p>
<p>必须要要知道的是就算有些函数像上面定义的内联函数那样也是不能被内联的。比如，虚函数和迭代函数一般都不能被内联。让一个虚函数内联的主要原因是把它定义在类里面，不管是为了方便还是为它的行为提供文档参考，比如类成员的访问函数和设置函数。</p>
</div>
</div>
<div class="section" id="inl">
<h3>-inl 文件<a class="headerlink" href="#inl" title="Permalink to this headline">¶</a></h3>
<p>必要的时候，我们可以用 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 后缀的文件来定义复杂的内联函数。</p>
<p>内联函数的定义必须在一个头文件中，这样编译器在调用它们的地方就能知道它的函数定义。然而实现代码应当在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中，我们也不喜欢有很多实现代码在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中，除非这样做能够提高可读性和性能。</p>
<p>如果一个内联函数的定义特别短，基本没有逻辑语句在里面，那么你可以把实现代码写在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中。比如，类成员的设置和访问函数的实现就写在类声明里面。为方便实现者和调用者，更复杂的内联函数也可以放在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中，如果这样让 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件太笨拙的话，可以把代码放在一个分离的 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 文件中。这样能把实现代码从类定义里面分离出来，当需要的时候仍然可以把这些 <tt class="docutils literal"><span class="pre">.inl.h</span></tt> 文件包含进来。</p>
<p><tt class="docutils literal"><span class="pre">-inl.h</span></tt> 文件的另一个用途是函数模板的定义。这样可以让你的模板定义更容易阅读。</p>
<p>记住 <tt class="docutils literal"><span class="pre">-inl.h</span></tt> 文件和其它头文件一样也需要 <tt class="docutils literal"><span class="pre">#define</span></tt> 保护。</p>
</div>
<div class="section" id="id12">
<h3>函数参数顺序<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>当定义一个函数的时候，参数的顺序是这样的 ：输入参数，然后是输出参数。</p>
<p>C/C++ 函数的参数要么是只有输入，要么是只有输出，要么都有。输入参数一般都是常量值或者有 <tt class="docutils literal"><span class="pre">const</span></tt> 限制的，然而输出参数或者输入/输出参数不会有 <tt class="docutils literal"><span class="pre">const</span></tt> 限制。当我们对函数参数排序的时候，把所有只用作输入的参数放在所有输出参数之前。不要因为要新添参数就把它放在最后，应该还是按照规定输入输出顺序来放置。</p>
<p>当然，这也不是一个不可违逆的规则，一些既是输入又是输出的参数（经常是类或者结构体）会把这个规则搞乱。所以，保持这些函数的一致性有时需要你不一定完全遵守规则。</p>
</div>
<div class="section" id="includes">
<h3>includes 文件的名字和顺序<a class="headerlink" href="#includes" title="Permalink to this headline">¶</a></h3>
<p>要用标准的顺序来保证可读性并且避免隐含的依赖，标准的先后顺序是 : C 的头文件，C++ 的头文件， 其它第三方库的头文件和自己工程的头文件。</p>
<p>工程的所有头文件都应该安装源代码目录树的顺序来排列，而不要使用 UNIX 的简化目录 <tt class="docutils literal"><span class="pre">.</span></tt> (当前目录) 和 <tt class="docutils literal"><span class="pre">..</span></tt> （上级目录）。比如， <tt class="docutils literal"><span class="pre">google-awesome-project/src/base/logging.h</span></tt> 应该这样被包含 ：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &quot;base/logging.h&quot;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">dir/foo.cc</span></tt> 或者 <tt class="docutils literal"><span class="pre">dir/foo_test.cc</span></tt> 文件的主要功能是实现并且测试 <tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> 文件中的东西，头文件包含的顺序应该是 ：</p>
<blockquote>
<div><ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> (优先位置，详情如下)</li>
<li>C 的头文件</li>
<li>C++ 的头文件</li>
<li>其它库的头文件</li>
<li>工程的头文件</li>
</ol>
</div></blockquote>
<p>对于优先的头文件，如果 <tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> 遗漏了任何必需的 <tt class="docutils literal"><span class="pre">includes</span></tt> 行， <tt class="docutils literal"><span class="pre">dir/foo.cc</span></tt> 或者 <tt class="docutils literal"><span class="pre">dir/foo_test.cc</span></tt> 的编译都会有问题。因此，这条规则保证构建出错的时候第一个提示是对应的的头文件，而不是其它库的“无辜”的头文件。</p>
<p><tt class="docutils literal"><span class="pre">dir/foo.cc</span></tt> 和 <tt class="docutils literal"><span class="pre">dir2/foo2.h</span></tt> 一般都在统一个目录（比如 <tt class="docutils literal"><span class="pre">base/basictypes_test.cc</span></tt> 和 <tt class="docutils literal"><span class="pre">base/basictypes.h</span></tt> )，但是也可以在不同的目录。</p>
<p>在每一个分类中，头文件包含的顺序都要按照字母表排序，注意比较老的代码可能没有遵守这个规则，如果方便的话就更改一下。</p>
<p>比如， <tt class="docutils literal"><span class="pre">google-awesome-project/src/foo/internal/fooserver.cc</span></tt> 文件的 <tt class="docutils literal"><span class="pre">include</span></tt> 行可能看起来是这样的 ：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &quot;foo/public/fooserver.h&quot;  </span><span class="c1">// Preferred location.</span>

<span class="cp">#include &lt;sys/types.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;hash_map&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="cp">#include &quot;base/basictypes.h&quot;</span>
<span class="cp">#include &quot;base/commandlineflags.h&quot;</span>
<span class="cp">#include &quot;foo/public/bar.h&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>范围<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id14">
<h3>命名空间<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>应该鼓励在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中用未命名的命名空间。对于有名字的命名空间，要根据项目名，最好和它所在的目录一起来命名该命名空间。不要直接使用 <tt class="docutils literal"><span class="pre">using</span></tt> 语句来使用命名空间。</p>
<div class="section" id="id15">
<h4>定义 :<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>命名空间把全局范围分成不同的区域，有效的防止了全局范围内的命名冲突。</p>
</div>
<div class="section" id="id16">
<h4>优点 :<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>除了类提供命名层次外，命名空间提供了这个功能。</p>
<p>比如，如果两个不同的工程在全局都有一个叫做 <tt class="docutils literal"><span class="pre">Foo</span></tt> 的类，这种命名在编译或者运行时可能会有冲突。如果每一个工程把它们各自的代码放在自己的命名空间里，就可以避免这个问题。 <tt class="docutils literal"><span class="pre">project1::Foo</span></tt> 和 <tt class="docutils literal"><span class="pre">project2::Foo</span></tt> 就能把这种冲突给消除。</p>
</div>
<div class="section" id="id17">
<h4>缺点 :<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>命名空间可能会让人混淆，因为除了类的层次外，命名空间又提供了一种额外的命名层次。</p>
<p>在头文件中使用未命名的命名空间很容易违反 C++ 的“只能定义一次”规则。</p>
</div>
<div class="section" id="id18">
<h4>总结 ：<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>用下面的方法来使用命名空间。用下面的例子终结所有对命名空间的讨论。</p>
<p>未命名的命名空间规则如下：</p>
<ul class="simple">
<li>允许甚至鼓励在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中使用未命名的命名空间，这样能够避免运行时的冲突：</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="n">namespace</span> <span class="p">{</span>                           <span class="c1">// This is in a .cc file.</span>

<span class="c1">// The content of a namespace is not indented</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">kUnused</span><span class="p">,</span> <span class="n">kEOF</span><span class="p">,</span> <span class="n">kError</span> <span class="p">};</span>       <span class="c1">// Commonly used tokens.</span>
<span class="n">bool</span> <span class="nf">AtEof</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pos_</span> <span class="o">==</span> <span class="n">kEOF</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// Uses our namespace&#39;s EOF.</span>

<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
<p>然而对于和特性类相关联的文件范围内声明，我们一般把它们定义成类型，数据成员或者静态成员，而不是把它们定义在未命名的命名空间里。</p>
<ul class="simple">
<li>不要在 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中使用未命名的命名空间。</li>
</ul>
<p>命名的命名空间规则如下：</p>
<ul class="simple">
<li>命名空间要把 <tt class="docutils literal"><span class="pre">includes</span></tt> 行，全局定义或声明，其它命名空间类的前向声明之后所有的内容都包含：</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// In the .h file</span>
<span class="n">namespace</span> <span class="n">mynamespace</span> <span class="p">{</span>

<span class="c1">// All declarations are within the namespace scope.</span>
<span class="c1">// Notice the lack of indentation.</span>
<span class="n">class</span> <span class="n">MyClass</span> <span class="p">{</span>
 <span class="nl">public:</span>
   <span class="p">...</span>
     <span class="kt">void</span> <span class="n">Foo</span><span class="p">();</span>
     <span class="p">};</span>

  <span class="p">}</span>  <span class="c1">// namespace mynamespace</span>
  <span class="c1">// In the .cc file</span>
  <span class="n">namespace</span> <span class="n">mynamespace</span> <span class="p">{</span>

  <span class="c1">// Definition of functions is within scope of the namespace.</span>
  <span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">}</span>

 <span class="p">}</span>  <span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
<p>一般的 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件可能有更复杂的细节，比如对其它命名空间的类的引用等。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &quot;a.h&quot;</span>

<span class="n">DEFINE_bool</span><span class="p">(</span><span class="n">someflag</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">&quot;dummy flag&quot;</span><span class="p">);</span>

<span class="n">class</span> <span class="n">C</span><span class="p">;</span>  <span class="c1">// Forward declaration of class C in the global namespace.</span>
<span class="n">namespace</span> <span class="n">a</span> <span class="p">{</span> <span class="n">class</span> <span class="n">A</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// Forward declaration of a::A.</span>

<span class="n">namespace</span> <span class="n">b</span> <span class="p">{</span>

<span class="p">...</span><span class="n">code</span> <span class="k">for</span> <span class="n">b</span><span class="p">...</span>         <span class="c1">// Code goes against the left margin.</span>

<span class="p">}</span>  <span class="c1">// namespace b</span>
</pre></div>
</div>
<ul class="simple">
<li>不要声明命名空间 <tt class="docutils literal"><span class="pre">std</span></tt> 下的任何内容，包括标准库类的前向声明。声明命名空间 <tt class="docutils literal"><span class="pre">std</span></tt> 中的实体会导致未知的行为，比如不可移植性。为了声明标准库中的实体，可以包含相应的头文件。</li>
<li>不应改直接用一个 <tt class="docutils literal"><span class="pre">using</span></tt> 语句使该命名空间中的所有名字都可用。</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Forbidden -- This pollutes the namespace.</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>可以在任何位置用 <tt class="docutils literal"><span class="pre">using</span></tt> 声明，比如 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件，函数里，方法里或者 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中。</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// OK in .cc files.</span>
<span class="c1">// Must be in a function, method or class in .h files.</span>
<span class="n">using</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>可以在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件的任何位置使用命名空间别名，在包含整个 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件的有名字的命名空间内，函数和方法内，也可以使用命名空间别名。</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Shorten access to some commonly used names in .cc files.</span>
<span class="n">namespace</span> <span class="n">fbz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>

<span class="c1">// Shorten access to some commonly used names (in a .h file).</span>
<span class="n">namespace</span> <span class="n">librarian</span> <span class="p">{</span>
<span class="c1">// The following alias is available to all files including</span>
<span class="c1">// this header (in namespace librarian):</span>
<span class="c1">// alias names should therefore be chosen consistently</span>
<span class="c1">// within a project.</span>
<span class="n">namespace</span> <span class="n">pd_s</span> <span class="o">=</span> <span class="o">::</span><span class="n">pipeline_diagnostics</span><span class="o">::</span><span class="n">sidetable</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">my_inline_function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// namespace alias local to a function (or method).</span>
    <span class="n">namespace</span> <span class="n">fbz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>
      <span class="p">...</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace librarian</span>
</pre></div>
</div>
<p>要知道 <tt class="docutils literal"><span class="pre">.h</span></tt> 文件中的别名在任何包含这个头文件的文件中都是有效的，所以那些公共的头文件（在工程外可用）和它们包含的一些头文件都应该避免使用别名，因为一般来说应该把公共 API 的范围控制到最小。</p>
</div>
</div>
<div class="section" id="id19">
<h3>嵌套类<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>当一个嵌套类是接口的一部分时，可能就会用到，但是最好用命名空间把它们的定义从全局范围隔离开来。</p>
<div class="section" id="id20">
<h4>定义<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>在一个类里面可以定义另一个类，也可以叫作成员类。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">class</span> <span class="n">Foo</span> <span class="p">{</span>

<span class="nl">private:</span>
    <span class="c1">// Bar is a member class, nested within Foo.</span>
    <span class="n">class</span> <span class="n">Bar</span> <span class="p">{</span>
         <span class="p">...</span>
    <span class="p">};</span>

<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4>优点<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>当嵌套类（或者成员类）只在类里面被使用的话是很有用的；把它作为一个成员放在类里面比声明在外面要好的多。嵌套类可以前向声明在包含它的类里面，并且在 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件中定义它，这样可以避免在类中有嵌套类的定义，这样嵌套类的定义就只与实现文件有关了。</p>
</div>
<div class="section" id="id22">
<h4>缺点<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>嵌套类在被前向声明的时候只能连同包含它的类一起。因此，任何操作 <tt class="docutils literal"><span class="pre">Foo::Bar*</span></tt> 指针的头文件都必须包含 <tt class="docutils literal"><span class="pre">Foo</span></tt> 整个类的声明。</p>
</div>
<div class="section" id="id23">
<h4>总结<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>除了当嵌套类是接口的一部分外，不要把嵌套类声明成公开的，比如一些方法使用了这个类的选项。</p>
</div>
</div>
<div class="section" id="id24">
<h3>非成员函数，静态成员函数和全局函数<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h3>
<p>最好使用命名空间中的非成员函数或者静态成员函数，而不要使用全局函数。</p>
<div class="section" id="id25">
<h4>优点<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h4>
<p>非成员函数和静态成员函数有时非常有用。把非成员函数放在命名空间中可以避免对全局作用域的污染。</p>
</div>
<div class="section" id="id26">
<h4>缺点<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<p>把非成员函数喝静态成员函数作为一个新类的成员或许会更有意义，特别是当它们想访问外部资源或者有明显的依赖关系的时候。</p>
</div>
<div class="section" id="id27">
<h4>总结<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>有时定义一个没有绑定到类的函数是很有用的，甚至是必须的。它们可以是非成员函数或者是静态成员函数。非成员函数不要对外部变量有依赖并且几乎要存在在一个命名空间里。相比于新创建一个类来把静态成员函数集合起来，使用命名空间可能更好一点。</p>
<p>作为生产类，定义在同一个编译单元内的函数在被其它编译单元调用的时候会引入不必要的耦合和链接时的依赖关系，静态成员函数对这一点尤为敏感。考虑新建一个类或者可能的话把这些函数放在一个命名空间中。</p>
<p>如果一定要定义一个非成员函数并且只有 <tt class="docutils literal"><span class="pre">.cc</span></tt> 文件用到它的话，用一个未名的命名空间或者 <tt class="docutils literal"><span class="pre">static</span></tt> 关键字（比如 <tt class="docutils literal"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">Foo()</span></tt> ）来限制它们的范围。</p>
</div>
</div>
<div class="section" id="id28">
<h3>局部变量<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h3>
<p>尽可能将函数的局部变量限制在最小的作用范围内，最好在声明它的时候就初始化。</p>
<p>C++ 允许在函数的任何地方声明变量。我们提倡在尽可能小的作用域里声明它们，离第一次使用越近越好。这样阅读的人也更容易找到它的声明知道变量的类型和初始值。特别的，应该用初始化代替声明和定义，比如：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>      <span class="c1">// Bad -- initialization separate from declaration.</span>
</pre></div>
</div>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="p">();</span>  <span class="c1">// Good -- declaration has initialization.</span>
</pre></div>
</div>
<p>注意 <tt class="docutils literal"><span class="pre">gcc</span></tt> 编译器可以正确执行 <tt class="docutils literal"><span class="pre">for</span> <span class="pre">(int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10;</span> <span class="pre">i++)</span></tt> (<tt class="docutils literal"><span class="pre">i</span></tt> 的作用域在循环里面)，因此你可以在其它的 <tt class="docutils literal"><span class="pre">for</span></tt> 循环中再次使用变量 <tt class="docutils literal"><span class="pre">i</span></tt> 。在 <tt class="docutils literal"><span class="pre">if</span></tt> 和 <tt class="docutils literal"><span class="pre">while</span></tt> 语句中这样声明也是正确的，比如：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">))</span> <span class="n">str</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>警告一下：如果变量是一个对象，每当进入作用域都要调用其构造函数，每次离开作用域都要调用其析构函数。</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Inefficient implementation:</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>  <span class="c1">// My ctor and dtor get called 1000000 times each.</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在循环外面声明这样的变量会更有效率一些：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>  <span class="c1">// My ctor and dtor get called once each.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id29">
<h3>静态变量和全局变量<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<p>类的静态变量或者全局变量是禁止的：由于构造和析构函数执行的顺序不确定性，很容易引起找不到定义的错误。然而 <tt class="docutils literal"><span class="pre">const</span></tt> 修饰的变量是可以这样声明的因为它们不会动态初始化或者析构。</p>
<p>静态存储期的对象，包括全局变量，静态变量，静态成员变量，静态函数变量，一定要是简单的数据类型：整型，字符，浮点，数组或者结构。</p>
<p>在 C++ 中，对类的静态变量的构造和初始化的顺序只是部分定义的，每次构建可能都不一样，这样就很可能出现很难查找的 bug。因此除了禁止类的全局变量，我们也不允许静态变量在函数中初始化，除非那些函数自身不依赖其它的全局变量。</p>
<p>同样的，析构函数被调用的顺序和构造函数是相反的，由于构造顺序是不确定的，所以析构的顺序也是不确定的。比如，在程序结束的时候一个静态变量可能已经被销毁了，带是代码仍然在运行，可能在其它的线程里，想要获取它的值但是会失败。或者是一个静态 <tt class="docutils literal"><span class="pre">string</span></tt> 类型的变量肯能在销毁之前被另一个变量引用了，那么析构之后也会出错。</p>
<p>总而言之，我们只允许普通数据类型的静态变量。所以完全不允许 <tt class="docutils literal"><span class="pre">vector</span></tt> (用 C 的数组代替) 或者 <tt class="docutils literal"><span class="pre">string</span></tt> （用 <tt class="docutils literal"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">[]</span></tt> 代替） 的静态变量。</p>
<p>如果你需要一个静态或者全局的类类型的变量，考虑在 <tt class="docutils literal"><span class="pre">main()</span></tt> 函数或者 <tt class="docutils literal"><span class="pre">pthread_once()</span></tt> 函数中用指针去初始化（）。注意一定要是一个原始的指针，因为聪明的指针析构存在我们正在避免的析构顺序问题。</p>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="introduction.html">序言</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, wangwei.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>